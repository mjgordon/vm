# ==============================================
#         ELEMENTARY CELLUAR AUTOMATA
# ==============================================

# Input rule (H L)
IO PUSH PUSH

# Set initial condition
LIT PUSH 2 PUSH 0 PUSH 0 X POP
LIT PUSH 0 PUSH 0 PUSH 0 Y POP
LIT PUSH 15 MEM POP

# Set starting position
LIT PUSH 0 PUSH 0 PUSH 0 X POP
LIT PUSH 0 PUSH 0 PUSH 1 Y POP

@LOOP

# Compute current cell
CALL >ECA-COMPUTE

# Add 1 to X
X PUSH
ADDC3_1
X POP

# Skip to end of loop if X is not 1023
X PUSH LIT PUSH 3 PUSH 15 PUSH 15 EQUAL3 LIT PUSH >NOT-EDGE COND

# Set X to 0
CONST3_0 X POP

# Add 1 to Y
Y PUSH OUT12
Y PUSH
ADDC3_1
Y POP

# Go to END if y == 1023
Y PUSH LIT PUSH 3 PUSH 15 PUSH 15 EQUAL3 NOT LIT PUSH >END COND
#Y PUSH LIT PUSH 0 PUSH 0 PUSH 4 EQUAL3 NOT LIT PUSH >END COND

@NOT-EDGE
GOTO >LOOP


# =============================================
#             ECA CELL COMPUTATION
# IN : Rule on the stack (H L)
# Sets the memory cell for the current X Y
# OUT : Rule remains on the stack (H L)
# =============================================

@ECA-COMPUTE
# Copy the input 
PEEK PEEK

# === DATAPOINT 0 ===
# If X is 0, put 0 on the stack
X PUSH CONST3_0 EQUAL3 NOT LIT PUSH >INPUT0-0 COND
# Else add the datapoint from memory
X PUSH Y PUSH
X PUSH LIT PUSH 1 SUB31 X POP
Y PUSH LIT PUSH 1 SUB31 Y POP
MEM PUSH RSTK POP
Y POP X POP
RSTK PUSH
GOTO >INPUT0-END

@INPUT0-0
LIT PUSH 0

@INPUT0-END

# === DATAPOINT 1 ===
Y PUSH
Y PUSH LIT PUSH 1 SUB31 Y POP
MEM PUSH RSTK POP
Y POP
RSTK PUSH

# === DATAPOINT 2 ===
# If X is 1023, put 0 on the stack
X PUSH LIT PUSH 3 PUSH 15 PUSH 15 EQUAL3 NOT LIT PUSH >INPUT2-0 COND
# Else add the datapoint from memory
X PUSH Y PUSH
X PUSH ADDC3_1 X POP
Y PUSH LIT PUSH 1 SUB31 Y POP
MEM PUSH RSTK POP
Y POP X POP
RSTK PUSH
GOTO >INPUT2-END

@INPUT2-0
LIT PUSH 0

@INPUT2-END

# Compile value
RSTK POP POP
BIN LIT PUSH 4 MULT DROP1
RSTK PUSH BIN LIT PUSH 2 MULT DROP1
RSTK PUSH BIN
ADD POP POP

# Wack switch statement equivalent
DUP RSTK POP
LIT PUSH >RESULT-0 COND RSTK PUSH DUP RSTK POP
LIT PUSH 1 SUB POP LIT PUSH >RESULT-1 COND RSTK PUSH DUP RSTK POP
LIT PUSH 2 SUB POP LIT PUSH >RESULT-2 COND RSTK PUSH DUP RSTK POP
LIT PUSH 3 SUB POP LIT PUSH >RESULT-3 COND RSTK PUSH DUP RSTK POP
LIT PUSH 4 SUB POP LIT PUSH >RESULT-4 COND RSTK PUSH DUP RSTK POP
LIT PUSH 5 SUB POP LIT PUSH >RESULT-5 COND RSTK PUSH DUP RSTK POP
LIT PUSH 6 SUB POP LIT PUSH >RESULT-6 COND RSTK PUSH DUP RSTK POP
LIT PUSH 7 SUB POP LIT PUSH >RESULT-7 COND RSTK PUSH DUP RSTK POP

# Default case, this shouldn't happen
LIT PUSH 0
GOTO >SWITCH-END

@RESULT-0
DROP1 LIT PUSH 1 AND
GOTO >SWITCH-END

@RESULT-1
DROP1 LIT PUSH 2 AND
GOTO >SWITCH-END

@RESULT-2
DROP1 LIT PUSH 4 AND
GOTO >SWITCH-END

@RESULT-3
DROP1 LIT PUSH 8 AND
GOTO >SWITCH-END

@RESULT-4
DROP LIT PUSH 1 AND
GOTO >SWITCH-END

@RESULT-5
DROP LIT PUSH 2 AND
GOTO >SWITCH-END

@RESULT-6
DROP LIT PUSH 4 AND
GOTO >SWITCH-END

@RESULT-7
DROP LIT PUSH 8 AND
GOTO >SWITCH-END

@SWITCH-END
TRUE MEM POP
RSTK PUSH DROP
RET


@END
# Drop the input 
DROP DROP