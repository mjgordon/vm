
* TODO
** Notation:
- B : Bug
- C : Generic Change
- F : New Feature
- O : Optimize
- R : Refactor
- T : Test

- AS : Assembler
- CM : Compiler
- VM : Virtual machine
- PR : Project structure

** v001 Basic VM and assembler [13/13]
- [X] +/- Become modes
- [X] Flag mode becomes RSTK mode.  
- [X] More efficient horizontal breshenham
- [X] Add vertical breshenham
- [X] Accept blank lines in assembly
- [X] Proper comments in assembly
- [X] Change way labels are handled, intern earlier
- [X] write emacs mode for .hxa
- [X] Finalize how calls and returns are handled when using RSTK, see above
- [X] Only create one dictionary per session. 
- [X] Finalize .hxa color-scheme - different color for rolled entries, cond should be same as goto?
- [X] Finalize test documentation
- [X] Finalize assembler documentation

*** TEST : test-opcodes.hxa [20/20]
- [X] 0 : 1 : COLOR
- [X] 1 : 3 : X
- [X] 2 : 3 : Y
- [X] 3 : 4 : PC
- [X] 4 : 1 : MEM
- [X] 5 : 1 : IO
- [X] 6 : 1 : RSTK
- [X] 7 : 1 : LIT
- [X] 8 : 2 -> 1 : +
- [X] 9 : 2 -> 1 : -

- [X] A : PUSH
- [X] B : POP
- [X] C : PEEK
- [X] D : COND
- [X] E : NOR
- [X] F : DRAW

EXPANSIONS
- [X] NOT
- [X] OR
- [X] AND
- [X] DUP
  
** v002 Additions to assembler and dictionary [27/34]
- [X] F AS : MULT expansion
- [X] F AS : MULT21 expansion
- [X] F AS : MULT22 expansion
- [X] F AS : DIV expansion
- [X] F AS : DIV21 expansion
- [ ] F AS : DIV22 expansion
- [ ] F AS : MOD expansion
- [X] F AS : DROP expansion
- [X] F AS : SWAP expansion
- [X] F AS : '+' Symbol for relative labels
- [X] C AS : Redefine CALL to use +
- [X] F AS : '%' Symbol for local labels
- [X] C AS : Make implementation of local labels smoother (definition requests # of gensyms)
- [X] C AS : Dictionary can now call different functions during expansion (e.g. +)
- [X] C VM : Replace EXECUTE with DROP
- [X] F VM : Add stack analysis in fast way
- [X] F VM : Reports execution time
- [X] F AS : Reports assembly time
- [X] F AS : Reports depth of expand token recursion
- [X] C AS : Clear sets and maps at start of assembly 
- [X] C AS : Assembler outputs file with same name as input
- [X] F VM : Read program file name as argument
- [X] F VM : Adaptive output mode
- [X] C VM : Make struct backend for output less stupid
- [X] R AS : Rename label and ref lists as sets in code
- [X] B VM : SDL window propery exits on close command
- [ ] R AS : Unify the way special symbols in code vs dictionary expansion are handled
- [X] R PR : hxa/hxb files should live in their own top level project directory. Others should write/read from there
- [ ] F AS : Token cleanup step: step through and remove redundant mode commands (e.g. the result of DROP DROP DROP)
- [X] T AS : Move math unit tests into their own file
- [X] B VM : Compiler warnings in vm.c
- [ ] O VM : Look for obvious optimizations
- [ ] Cleanup and document 

*** TEST : test-opcodes.hxa [2/6]
- [X] MULT
- [X] MULT22
- [ ] DIV
- [ ] DIV22
- [ ] MOD 
- [ ] DROP
- [ ] SWAP 
  
** v003 [0/2]
- [ ] R VM : Rename all opPush etc. functions to execPush etc. 
- [ ] T VM : Speed of main opcode branching being switch statement vs function pointer array
- [ ] S AS : use parse-integer instead of read-from-string
- [ ] R AS : get-dictionary-expander is fugly. Separate dictionary definition from expander function
- [ ] F AS : Expansion symbol ! : assembler chooses to expand it or make it a call
- [ ] F AS : Modes for : fastest, smallest, optimize/compromise
- [ ] F VM : Create heatmap export of bytecode program (as a compile option)
- [ ] F VM : Dumb update cycle, call update pixels every e.g. 1000 operations. This should fix ->
- [ ] B VM : ^C Doesn't exit when stuck in infinite loop
  
* BUGS

* Documentation
** Links:
https://www.vttoth.com/CMS/projects/13-4-bit-processor/134-viktors-amazing-4-bit-processor-architecture
https://github.com/qeedquan/turtle/blob/master/src/util.c


** General
Screen Storage:
80x25char @ 8x12 px = 640 x 300 px
2000 char @ 2nb = 4000 nb or roughly 4 pages

2nb = 256 values. Need 7 bits for 128 standard ascii.
Can either have full 256 ascii or use last bit as color.

Font Storage:
8x12 Mem rect Per Character. 8*128 = 1024 cells wide naively, 12,288 total or 3 pages
Or, 128 characters in 4 32-character blocks. Each bit per cell describes whether that pixel is on or off in each block. So: 8*32 = 256 cells wide, 3072 total (fits in one page).
Decoding might be slow though?

Variables:
Pointer = 8nb (1 : nb length, 1 : some other flag? , 3 : page, 3 : location)
512 Pointers per page.


** Symbols
@   : Label, assembler stores its position in a hashmap.
%   : Local label, the assembler will turn every expanded instance into a unique label 
>   : Label reference, assembler replacing with same named label position
+   : Anonymous/unique label, assembler stores its position in a hashmap with a gensym.
+32 : Stores the anonymous label with the associated offset. Used in calls
!   : Assembler can choose whether to expand the token locally or call its in-place expansion

** Opcodes
B : ∆ : MNMNC  : DESCRIPTION

0 : 1 : COLOR  : Color of line drawn with DRAW
1 : 3 : X      : Position in 'page' of memory dealt with. Destination x for draw.
2 : 3 : Y      : 'Page' of memory dealt with. Destination y for draw
3 : 4 : PC     : PUSH to view use current PC. POP to set PC (e.g. goto)
4 : 1 : MEM    : Load / Set a position in memory determined by X and Y
5 : 1 : IO     : PUSH to read a NB, POP to write a NB
6 : 1 : RSTK   : A second stack. Used by various expansions for a return stack
7 : 1 : LIT    : Push to put the next NB on the stack. Pop to ?(execute top NB / drop top NB)
8 : 2->1 : ADD : POP to add top two NB. PUSH to use carry flag of last operation
9 : 2->1 : SUB : POP to sub top two NB. PUSH to use underflow flag of last operation

A : N : PUSH   : Push selected mode location onto the stack
B : N : POP    : Pop the stack into the selected mode location
C : 1 : PEEK   : Copy part of the stack to the top of the stack
D : 5 : COND   : Go to the address at the top 4 positions of the stack if the 5th stack position is 0
E : 2->1 : NOR : Performs a logical NOR on the top two stack positions
F : 1 : DRAW   : Draws a line of COLOR between the last position and X/Y if the top position is 1. Else just move.

** Expansion mnemonics

- MNEMONIC       : STACK ∆   : DESCRIPTION

*** STACK OPERATION
DROP           : (-1) (0)  : Removes the top item of the stack
DUP            : (+1) (0)  : Copies the top item of the stack
SWAP           : (0)  (0)  : Swaps the top two items on the stack

*** LOGIC & COMPARISON
AND            : (-1) ()   : Performs a bitwise AND on the top two nb
OR             : (-1) ()   : Performs a bitwise OR on the top two nb
NOT            : (-1) ()   : Performs a bitwise NOT on the top two nb
TRUE           : (0)  (0)  : Converts the top of the stack to F (logical T) if not 0 (logical F)

*** MATH : ADDITION
ADD21          : (-1) ()   : Adds a one digit-number to a two-digit number

*** MATH : SUBTRACTION
SUB21          : (-1) (0)  : Subtracts a one-digit number from a two-digit number

*** MATH : MULTIPLICATION
MULT           : (0)  (0)  : Multiplies two one-digit numbers
MULT21         : (0)  (0)  : Multiplies a two-digit number by a one-digit numer
MULT22         : (0)  (0)  : Multiplies a two-digit number by a two-digit number


*** MATH : DIVISION
DIV            : (-1) (0)  : Divides a one-digit number by a one digit number. Sets FLAG if /0
DIV21          : (-1) (0)  : Divides a two-digit number by a one-digit number. Sets FLAG if /0

*** PROGRAM FLOW
GOTO >ADDR     : (0)  (0)  : Moves PC directly to >ADDR
CALL >ADDR     : (0)  (+4) : Puts a return position on the RSTK, moves PC to >ADDR
RET            : (0)  (-4) : Moves PC back to top position on the RSTK

*** IO
OUT            : (-1) (0)  : Outputs 1 nb from the stack
OUTINT8        : (-2) (0)  : Outputs 2 nb from the stack, formatted as an int
OUTINT12       : (-3) (0)  : Outputs 3 nb from the stack, formatted as an int
OUTINT16       : (-4) (0)  : Outputs 4 nb from the stack, formatted as an int


** Expansion Definitions
*** STACK OPERATION
_DROP                           (A) ()
LIT POP                         () ()
_RESULT                         (-1) (0)

_DUP                            (A) ()
PEEK 0                          (A A) ()
_RESULT                         (+ 1) ()

_SWAP                           (A B) ()
PEEK 1                          (A B A) ()
RSTK POP POP                    (A) (A B)
DROP                            () (A B)
RSTK PUSH PUSH                  (B A) ()
_RESULT                         (0) (0)

*** LOGIC AND COMPARISON

_TRUE                           (A) ()
LIT PUSH >0 COND                () ()
LIT PUSH 15                     (15) ()
GOTO >1                         () ()
%0
LIT PUSH 0                      (0) ()
%1
_RESULT                         (0) (0)                   

*** ADDITION
# ADD with carry. Ignores if next digit would overflow
_ADD21                          (A B C) ()
ADD POP RSTK POP ADD PUSH       (A F) (B+C)
ADD POP RSTK PUSH               (A+F B+C) ()
_RESULT                         (-1) (0)

*** SUBTRACTION

_SUB21                          (A B C) ()
SUB POP                         (A B-C) ()
RSTK POP SUB PUSH               (A F) (B-C)
SUB POP RSTK PUSH               (A-F B-C) ()
_RESULT                         (-1) (0)

*** MULTIPLICATION
# A and B are the factors. P and R are the digits of the product
# AxB = PR
_MULT                           (A B) ()
RSTK POP POP LIT PUSH 0 PUSH 0  (0 0) (B A)
%0                              (P R) (B A)
RSTK PUSH DUP                   (P R A A) (B)
RSTK PUSH DUP                   (P R A A B B) ()
LIT PUSH >1                     (P R A A B B >1) ()
COND(>1)                        (P R A A B) ()
LIT PUSH 1                      (P R A A B 1) ()
SUB POP                         (P R A A B-1) ()
RSTK POP POP                    (P R A) (B-1 A)
ADD POP                         (P R+A) (B-1 A)
RSTK POP ADD PUSH               (P F) (B-1 A R+A)
POP RSTK PUSH                   (P+F R+A) (B-1 A)
GOTO >0
%1                              (P R A A 0) ()
DROP DROP DROP                  (P R) ()
_RESULT                         (0) (0)

# Multiplies 0xAB and 0xCD
# Result should be 0xMNOP
# K is carry placeholders here
     AB
x    CD
=======
   MNOP
   0123

_MULT22                         (A B C D) ()
RSTK POP PEEK 2 PEEK 2          (A B C A B) (D)
RSTK POP POP                    (A B C) (D B A)
MULT21                          (M N O) (D B A)
RSTK PUSH PUSH PUSH             (M N O A B D) ()
MULT21                          (M Na Oa Nb Ob P) ()
RSTK POP POP                    (M Na Oa Nb) (P Ob)
SWAP RSTK POP                   (M Na Nb) (P Ob Oa)
ADD21                            (M+F N) (P Ob Oa)
RSTK PUSH PUSH                  (M+F N Oa Ob) (P)
ADD21                            (M+F N+F O) (P)
RSTK PUSH                       (M+F N+F O P) ()
_RESULT                         (0) (0)


_MULT21                         (A B C) ()
RSTK POP SWAP RSTK PUSH         (B A C) ()
DUP RSTK POP                    (B A C) (C)
MULT                            (B K T) (C)
PEEK 2 RSTK POP POP POP         (B) (C B T K)
DROP RSTK PUSH PUSH PUSH PUSH   (K T B C) ()
MULT                            (K T K T) ()
RSTK POP ADD POP                (M N) (O)
RSTK POP ADD PUSH               (M F) (O N)
ADD POP RSTK PUSH PUSH          (M+F N O) ()
_RESULT                         (0) (0)

*** DIVISION

# A is dividend, B is divisor, Q is quotient, F is underflow flag
# SUB underflow flag is set to 1 if attempting to divide by zero, created by subbing M and N at the end
# Uses one more GOTO than MULT, but only for the rarer divide by zero cases
_DIV                            (A B) ()
DUP LIT PUSH 1 SUB POP          (A B B-1) ()
DROP SUB PUSH TRUE NOT          (A B !F) ()
LIT PUSH >1 COND                (A B) ()
DUP RSTK POP POP POP LIT PUSH 0 (0) (B B A)
RSTK PUSH PUSH                  (0 A B) (B)
%0                              (Q A B) (B)
SUB POP                         (Q A-B) (B)
RSTK POP SUB PUSH               (Q F) (B A-B)
TRUE NOT                        (Q !F) (B A-B)
LIT PUSH >2                     (Q !F >2) (B A-B)
COND (>2)                       (Q) (B A-B)
LIT PUSH 1 ADD POP              (Q) (B A-B)
RSTK PUSH PUSH                  (Q A-B B) ()
DUP RSTK POP                    (Q A-B B) (B)
GOTO >0 
%1                              (A B) ()
DROP DROP                       () ()
LIT PUSH 0 PUSH 1 PUSH 2        (0 1 2) ()
GOTO >3
%2                              (Q) (B A-B)
RSTK PUSH PUSH                  (Q A-B B) () ()
DROP DROP                       (Q) ()
LIT PUSH 2 PUSH 1               (Q 2 1) ()
%3                              (Q M N) ()
SUB POP DROP                    (Q) ()
_RESULT                         (-1) ()

# AB is divident. C is divisor. Q is quotient, F is underflow fla
_DIV21                          (A B C) ()
DUP LIT PUSH 1 SUB POP          (A B C C -1) ()
DROP SUB PUSH TRUE NOT          (A B C !F) ()
LIT PUSH >1 COND                (A B C)
DUP RSTK POP POP POP POP        () (C C B A)
LIT PUSH 0 PUSH 0               (0 0) (C C B A)
RSTK PUSH PUSH PUSH             (0 0 A B C) (C)
%0
SUB21                           (Q R A-F B-C) (C)
RSTK POP POP SUB PUSH           (Q R F) (C B-C A-F)
TRUE NOT                        (Q R !F) (C B-C A-F)
LIT PUSH >2                     (Q R !F >2) (C B-C A-F)
COND (>2)                       (Q R) (C B-C A-F)
LIT PUSH 1 ADD21                (Q R) (C B-C A-F)
RSTK PUSH PUSH PUSH             (Q R A-F B-C C) ()
DUP RSTK POP                    (Q R A-F B-C C) (C) 
GOTO >0
%1                              (A B C)
DROP DROP DROP                  ()
LIT PUSH 0 PUSH 0 PUSH 1 PUSH 2 (0 0 1 2) ()
GOTO >3
%2 
RSTK PUSH PUSH PUSH             (Q R A-F B-C C) ()
DROP DROP DROP                  (Q R) ()
LIT PUSH 2 PUSH 1               (Q R 2 1) ()
%3
SUB POP DROP                    (Q R) ()
_RESULT                         (-1) ()




*** PROGRAM FLOW

# Reminder: PUSH >ADDR is automatically converted to the correct address
_GOTO >ADDR                     () ()
LIT PUSH >ADDR                  (A B C D) ()
PC POP                          () ()
_RESULT                         (0) (0)


# Pushes the current PC to RSTK, plus a constant equal to the size of the expansion itself
# Where 00XY is the call size
_CALL >ADDR                     () ()
LIT PUSH +23                    (A B C+1 D+13) ()
RSTK PUSH PUSH PUSH PUSH        () (D+Y C+X B A)
GOTO >ADDR                      () (D+Y C+X+F B A)
_RESULT                         (0) (+4)


# Where ABCD is the adjusted call point
_RETURN                         () (D C B A)
RSTK PUSH PUSH PUSH PUSH        (A B C D) ()
PC POP                          () ()
_RESULT                         (0) (-4)
*** IO


